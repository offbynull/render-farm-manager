package com.offbynull.rfm.host.services.h2db;

import com.offbynull.rfm.host.model.requirement.HostRequirement;
import com.offbynull.rfm.host.model.requirement.Requirement;
import com.offbynull.rfm.host.parser.Parser;
import static com.offbynull.rfm.host.services.h2db.InternalUtils.flattenRequirementHierarchy;
import static com.offbynull.rfm.host.services.h2db.InternalUtils.getRequirementChildren;
import static com.offbynull.rfm.host.services.h2db.InternalUtils.getRequirementKey;
import static com.offbynull.rfm.host.services.h2db.InternalUtils.getRequirementName;
import static com.offbynull.rfm.host.services.h2db.WorkerSearcherSql.filterByCachedCountAndCapacity;
import static com.offbynull.rfm.host.services.h2db.WorkerSearcherSql.filterByWhereCondition;
import java.util.ArrayList;
import static java.util.Collections.EMPTY_LIST;
import static java.util.Collections.EMPTY_MAP;
import java.util.List;
import java.util.Set;
import static java.util.stream.Collectors.joining;
import org.apache.commons.lang3.Validate;

final class WorkerSearcher {
    private WorkerSearcher() {
        // do nothing
    }
    
    public static void main(String[] args) {
        Parser parser = new Parser(EMPTY_LIST, EMPTY_LIST);
        HostRequirement hr = parser.parseScriptReqs(EMPTY_MAP, ""
                + "[1,5] host where host.n_class==5 && host.s_region==\"US-EAST\"{"
                + "  1 socket where socket.s_brand==\"intel\" {"
                + "    2 core where !core.b_hyperthread {"
                + "      [2,999999] cpu with 100000 capacity where cpu.b_avx==true && socket.s_model==\"xeon\" { }"
                + "      1 cpu with 5000 capacity where socket.s_model==\"haswell\" { }"
                + "    }"
                + "  }"
                + "  1 gpu with 1 capacity { }"
                + "  1 mount with 256gb capacity where mount.b_rotational==true" // for saving work
                + "  1 mount with 32gb capacity where mount.b_rotational==false" // for temp storage
                + "  1 ram with 64gb capacity where ram.n_speed>=3000 && ram.s_brand==\"samsung\" { }"
                + "}");
        
        Query qr = generateQuery(hr);
        System.out.println(qr.toJdbcQuery());
    }
    
    private static Query generateQuery(HostRequirement hostRequirement) {
        Validate.notNull(hostRequirement);
        
        // get hierarchy of hostRequirement, NOT INCLUDING hostRequirement itself
        //   we don't user hostRequirement directly because we don't want the query generated by filterByCachedCountAndCapacity() to take in
        //   the host count -- the count and capacity we're calculating is PER individual host, not a combination of multiple hosts.
        List<Requirement> parentRequirements = new ArrayList<>(getRequirementChildren(hostRequirement).values());
        
        // get host key -- s_host and n_port as of now, but done dynamically so this code will continue working if it changes
        Set<String> hostKey = getRequirementKey(hostRequirement);
        
        // generate query
        QueryTracker qt = new QueryTracker();
        String queryStr = ""
                + "SELECT " + hostKey.stream().collect(joining(",")) + "\n"
                + "FROM\n";
        
        
        String nextId = qt.alias("hostcount");
        Query nextQuery = filterByCachedCountAndCapacity("worker", parentRequirements);
        queryStr += ""
                + "(\n"
                + nextQuery.compose(2, qt)
                + "\n) " + nextId;
        
        for (List<Requirement> requirementChain : flattenRequirementHierarchy(hostRequirement)) {
            String aliasHint = requirementChain.stream().map(r -> getRequirementName(r)).collect(joining());
            
            String lastId = nextId;
            String _nextId = qt.alias(aliasHint); // hack so nextId can be used in lambda below (can't assign to nextId directly)
            
            nextQuery = filterByWhereCondition(requirementChain);
            queryStr += ""
                    + "\n"
                    + "INNER JOIN\n"
                    + "(\n"
                    + nextQuery.compose(2, qt)
                    + "\n) " + _nextId + "\n"
                    + "ON " + hostKey.stream().map(k -> lastId + "." + k + "=" + _nextId + "." + k).collect(joining(" AND "));
            
            nextId = _nextId;
        }
        
        Query query = new Query(queryStr, qt.params());
        return query;
    }
}
